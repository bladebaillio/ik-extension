{"entries":[{"timestamp":1742941405933,"editorVersion":"2.0.40","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":182,"length1":43,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":211,"length1":79,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"custom.ts","value":"/**\n * Inverse Kinematics Chain Extension for MakeCode Arcade\n */\n\n//% weight=100 color=#0050bb icon=\"\\uf256\"\n//% block=\"IK\"\nnamespace ikchain {\n    export class IKChain {\n        private segments: Segment[] = [];\n        private headSprite: Sprite;\n        private baseSprite: Sprite;\n        private totalLength: number = 0;\n        private thickness: number = 2;\n        private color: number = 1;\n        private jointSprites: Sprite[] = [];\n        private midSegmentSprites: { sprite: Sprite, segmentIndex: number, position: number }[] = [];\n\n        constructor(segmentCount: number, segmentLength: number, color: number, thickness: number, headSprite: Sprite, baseSprite: Sprite) {\n            this.headSprite = headSprite;\n            this.baseSprite = baseSprite;\n            this.color = color;\n            this.thickness = thickness;\n\n            // Create segments\n            for (let i = 0; i < segmentCount; i++) {\n                const segment = new Segment(segmentLength);\n                this.segments.push(segment);\n                this.totalLength += segmentLength;\n            }\n\n            // Initialize positions\n            this.initializePositions();\n        }\n\n        /**\n         * Initialize segment positions in a straight line from base\n         */\n        private initializePositions() {\n            if (!this.baseSprite || this.segments.length === 0) return;\n\n            const baseX = this.baseSprite.x;\n            const baseY = this.baseSprite.y;\n\n            // Initial angle (pointing upward)\n            const initialAngle = -Math.PI / 2;\n\n            let prevX = baseX;\n            let prevY = baseY;\n\n            for (let i = 0; i < this.segments.length; i++) {\n                const segment = this.segments[i];\n                segment.startX = prevX;\n                segment.startY = prevY;\n                segment.angle = initialAngle;\n\n                // Calculate end point\n                segment.endX = segment.startX + Math.cos(segment.angle) * segment.length;\n                segment.endY = segment.startY + Math.sin(segment.angle) * segment.length;\n\n                prevX = segment.endX;\n                prevY = segment.endY;\n            }\n        }\n\n        /**\n         * Add a sprite at a joint (kink) between segments\n         * @param sprite The sprite to add at the joint\n         * @param jointIndex The index of the joint (0 = base, 1 = after first segment, etc.)\n         */\n        public addJointSprite(sprite: Sprite, jointIndex: number) {\n            if (jointIndex < 0 || jointIndex > this.segments.length) {\n                return; // Invalid joint index\n            }\n\n            // Resize array if needed\n            while (this.jointSprites.length <= jointIndex) {\n                this.jointSprites.push(null);\n            }\n\n            this.jointSprites[jointIndex] = sprite;\n\n            // Position the sprite immediately\n            this.updateJointSprite(jointIndex);\n        }\n\n        /**\n         * Add a sprite between segments (along a segment)\n         * @param sprite The sprite to add along the segment\n         * @param segmentIndex The index of the segment (0 = first segment, etc.)\n         * @param position The position along the segment (0.0 = start, 1.0 = end)\n         */\n        public addMidSegmentSprite(sprite: Sprite, segmentIndex: number, position: number) {\n            if (segmentIndex < 0 || segmentIndex >= this.segments.length) {\n                return; // Invalid segment index\n            }\n\n            // Clamp position between 0 and 1\n            position = Math.max(0, Math.min(1, position));\n\n            this.midSegmentSprites.push({\n                sprite: sprite,\n                segmentIndex: segmentIndex,\n                position: position\n            });\n\n            // Position the sprite immediately\n            this.updateMidSegmentSprite(this.midSegmentSprites.length - 1);\n        }\n\n        /**\n         * Update the position of a joint sprite\n         * @param jointIndex The index of the joint\n         */\n        private updateJointSprite(jointIndex: number) {\n            const sprite = this.jointSprites[jointIndex];\n            if (!sprite) return;\n\n            let x: number, y: number;\n\n            if (jointIndex === 0) {\n                // Base joint\n                x = this.baseSprite.x;\n                y = this.baseSprite.y;\n            } else if (jointIndex === this.segments.length) {\n                // End effector joint\n                const lastSegment = this.segments[this.segments.length - 1];\n                x = lastSegment.endX;\n                y = lastSegment.endY;\n            } else {\n                // Middle joint\n                const segment = this.segments[jointIndex - 1];\n                x = segment.endX;\n                y = segment.endY;\n            }\n\n            sprite.x = x;\n            sprite.y = y;\n        }\n\n        /**\n         * Update the position of a mid-segment sprite\n         * @param index The index in the midSegmentSprites array\n         */\n        private updateMidSegmentSprite(index: number) {\n            const spriteInfo = this.midSegmentSprites[index];\n            if (!spriteInfo || !spriteInfo.sprite) return;\n\n            const segment = this.segments[spriteInfo.segmentIndex];\n            const position = spriteInfo.position;\n\n            // Interpolate position along the segment\n            const x = segment.startX + (segment.endX - segment.startX) * position;\n            const y = segment.startY + (segment.endY - segment.startY) * position;\n\n            spriteInfo.sprite.x = x;\n            spriteInfo.sprite.y = y;\n        }\n\n        /**\n         * Update the chain using inverse kinematics (FABRIK algorithm)\n         */\n        public update() {\n            if (!this.headSprite || !this.baseSprite || this.segments.length === 0) return;\n\n            const targetX = this.headSprite.x;\n            const targetY = this.headSprite.y;\n            const baseX = this.baseSprite.x;\n            const baseY = this.baseSprite.y;\n\n            // Check if target is reachable\n            const distanceToTarget = Math.sqrt(\n                (targetX - baseX) * (targetX - baseX) +\n                (targetY - baseY) * (targetY - baseY)\n            );\n\n            // FABRIK algorithm iterations\n            const iterations = 10; // More iterations = more accurate\n\n            if (distanceToTarget > this.totalLength) {\n                // Target is too far, just stretch in that direction\n                const angle = Math.atan2(targetY - baseY, targetX - baseX);\n\n                let currentX = baseX;\n                let currentY = baseY;\n\n                for (let i = 0; i < this.segments.length; i++) {\n                    const segment = this.segments[i];\n                    segment.startX = currentX;\n                    segment.startY = currentY;\n                    segment.angle = angle;\n\n                    // Calculate end point\n                    segment.endX = segment.startX + Math.cos(angle) * segment.length;\n                    segment.endY = segment.startY + Math.sin(angle) * segment.length;\n\n                    currentX = segment.endX;\n                    currentY = segment.endY;\n                }\n            } else {\n                // Target is reachable, use FABRIK\n                for (let iteration = 0; iteration < iterations; iteration++) {\n                    // FORWARD REACHING\n                    // Set the end effector (last segment end) to target position\n                    this.segments[this.segments.length - 1].endX = targetX;\n                    this.segments[this.segments.length - 1].endY = targetY;\n\n                    // Work backwards from the end effector to the base\n                    for (let i = this.segments.length - 1; i >= 0; i--) {\n                        const segment = this.segments[i];\n\n                        // If not the last segment, set the current segment's end to the next segment's start\n                        if (i < this.segments.length - 1) {\n                            segment.endX = this.segments[i + 1].startX;\n                            segment.endY = this.segments[i + 1].startY;\n                        }\n\n                        // Adjust the start point to maintain segment length\n                        const dx = segment.endX - segment.startX;\n                        const dy = segment.endY - segment.startY;\n                        const currentLength = Math.sqrt(dx * dx + dy * dy);\n\n                        if (currentLength > 0) {\n                            const ratio = segment.length / currentLength;\n                            segment.startX = segment.endX - dx * ratio;\n                            segment.startY = segment.endY - dy * ratio;\n                        }\n\n                        // If not the first segment, update the previous segment's end position\n                        if (i > 0) {\n                            this.segments[i - 1].endX = segment.startX;\n                            this.segments[i - 1].endY = segment.startY;\n                        }\n                    }\n\n                    // BACKWARD REACHING\n                    // Fix the base position\n                    this.segments[0].startX = baseX;\n                    this.segments[0].startY = baseY;\n\n                    // Work forwards from the base to the end effector\n                    for (let i = 0; i < this.segments.length; i++) {\n                        const segment = this.segments[i];\n\n                        // If not the first segment, set the current segment's start to the previous segment's end\n                        if (i > 0) {\n                            segment.startX = this.segments[i - 1].endX;\n                            segment.startY = this.segments[i - 1].endY;\n                        }\n\n                        // Adjust the end point to maintain segment length\n                        const dx = segment.endX - segment.startX;\n                        const dy = segment.endY - segment.startY;\n                        const currentLength = Math.sqrt(dx * dx + dy * dy);\n\n                        if (currentLength > 0) {\n                            const ratio = segment.length / currentLength;\n                            segment.endX = segment.startX + dx * ratio;\n                            segment.endY = segment.startY + dy * ratio;\n                        }\n\n                        // Update segment angle\n                        segment.angle = Math.atan2(segment.endY - segment.startY, segment.endX - segment.startX);\n\n                        // If not the last segment, update the next segment's start position\n                        if (i < this.segments.length - 1) {\n                            this.segments[i + 1].startX = segment.endX;\n                            this.segments[i + 1].startY = segment.endY;\n                        }\n                    }\n                }\n            }\n\n            // Update head sprite position to match end of last segment\n            const lastSegment = this.segments[this.segments.length - 1];\n            this.headSprite.x = lastSegment.endX;\n            this.headSprite.y = lastSegment.endY;\n\n            // Update all joint sprites\n            for (let i = 0; i < this.jointSprites.length; i++) {\n                this.updateJointSprite(i);\n            }\n\n            // Update all mid-segment sprites\n            for (let i = 0; i < this.midSegmentSprites.length; i++) {\n                this.updateMidSegmentSprite(i);\n            }\n\n            // Draw the chain\n            this.draw();\n        }\n\n        /**\n         * Draw the chain on the screen\n         */\n        private draw() {\n            for (let i = 0; i < this.segments.length; i++) {\n                const segment = this.segments[i];\n\n                // Draw thick line on the screen\n                this.drawThickLine(\n                    segment.startX,\n                    segment.startY,\n                    segment.endX,\n                    segment.endY,\n                    this.thickness,\n                    this.color\n                );\n            }\n        }\n\n        /**\n         * Draw a thick line by drawing multiple parallel lines\n         */\n        private drawThickLine(x1: number, y1: number, x2: number, y2: number, thickness: number, color: number) {\n            // Draw the main line\n            scene.backgroundImage().drawLine(x1, y1, x2, y2, color);\n\n            if (thickness <= 1) return;\n\n            // Calculate perpendicular direction for thickness\n            const angle = Math.atan2(y2 - y1, x2 - x1);\n            const perpAngle = angle + Math.PI / 2;\n            const perpX = Math.cos(perpAngle);\n            const perpY = Math.sin(perpAngle);\n\n            // Draw additional lines for thickness\n            const halfThickness = Math.floor(thickness / 2);\n            for (let t = 1; t <= halfThickness; t++) {\n                // Draw line above\n                scene.backgroundImage().drawLine(\n                    x1 + perpX * t,\n                    y1 + perpY * t,\n                    x2 + perpX * t,\n                    y2 + perpY * t,\n                    color\n                );\n\n                // Draw line below\n                scene.backgroundImage().drawLine(\n                    x1 - perpX * t,\n                    y1 - perpY * t,\n                    x2 - perpX * t,\n                    y2 - perpY * t,\n                    color\n                );\n            }\n        }\n    }\n\n    class Segment {\n        public startX: number = 0;\n        public startY: number = 0;\n        public endX: number = 0;\n        public endY: number = 0;\n        public angle: number = 0;\n        public length: number = 0;\n\n        constructor(length: number) {\n            this.length = length;\n        }\n    }\n\n    let chains: IKChain[] = [];\n    /**\n     * Create an inverse kinematics chain\n     * @param segments Number of segments in the chain\n     * @param length Length of each segment\n     * @param color Color of the chain segments\n     * @param thickness Thickness of the chain segments\n     * @param head Sprite to use as the head of the chain\n     * @param base Sprite to use as the base of the chain\n     */\n    //% block=\"make IK chain with $segments segments with length of $length with color $color with thickness $thickness with $head as head and $base as base\"\n    //% segments.min=1 segments.max=20 segments.defl=3\n    //% length.min=1 length.max=100 length.defl=20\n    //% color.min=1 color.max=15 color.defl=1\n    //% thickness.min=1 thickness.max=10 thickness.defl=2\n    //% head.shadow=variables_get\n    //% base.shadow=variables_get\n    //% weight=100\n    export function createIKChain(segments: number, length: number, color: number, thickness: number, head: Sprite, base: Sprite): IKChain {\n        const chain = new IKChain(segments, length, color, thickness, head, base);\n        chains.push(chain);\n        return chain;\n    }\n\n    /**\n     * Add a sprite at a joint (kink) between segments\n     * @param chain The IK chain to add the sprite to\n     * @param sprite The sprite to add at the joint\n     * @param jointIndex The index of the joint (0 = base, 1 = after first segment, etc.)\n     */\n    //% block=\"add $sprite at joint $jointIndex on $chain\"\n    //% sprite.shadow=variables_get\n    //% jointIndex.min=0 jointIndex.max=20 jointIndex.defl=1\n    //% chain.shadow=variables_get\n    //% weight=95\n    export function addJointSprite(chain: IKChain, sprite: Sprite, jointIndex: number) {\n        chain.addJointSprite(sprite, jointIndex);\n    }\n\n    /**\n     * Add a sprite along a segment\n     * @param chain The IK chain to add the sprite to\n     * @param sprite The sprite to add along the segment\n     * @param segmentIndex The index of the segment (0 = first segment, etc.)\n     * @param position The position along the segment (0.0 = start, 1.0 = end)\n     */\n    //% block=\"add $sprite along segment $segmentIndex at position $position on $chain\"\n    //% sprite.shadow=variables_get\n    //% segmentIndex.min=0 segmentIndex.max=19 segmentIndex.defl=0\n    //% position.min=0 position.max=1 position.defl=0.5\n    //% chain.shadow=variables_get\n    //% weight=90\n    export function addMidSegmentSprite(chain: IKChain, sprite: Sprite, segmentIndex: number, position: number) {\n        chain.addMidSegmentSprite(sprite, segmentIndex, position);\n    }\n\n    /**\n     * Update all IK chains\n     */\n    //% block=\"update all IK chains\"\n    //% weight=85\n    export function updateAllChains() {\n        for (const chain of chains) {\n            chain.update();\n        }\n    }\n\n    /**\n     * Update a specific IK chain\n     * @param chain The chain to update\n     */\n    //% block=\"update $chain\"\n    //% chain.shadow=variables_get\n    //% weight=80\n    export function updateChain(chain: IKChain) {\n        chain.update();\n    }\n}\n\n"}]}],"snapshots":[{"timestamp":1742941405932,"editorVersion":"2.0.40","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"IK extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1742941502473}